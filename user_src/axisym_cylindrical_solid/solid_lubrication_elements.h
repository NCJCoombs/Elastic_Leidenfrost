// Solid lubrication element.
#ifndef OOMPH_SOLID_LUBRICATION_HEADER
#define OOMPH_SOLID_LUBRICATION_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// Standard libray headers
#include <cmath>

// oomph-lib headers
#include "../generic/Qelements.h"

namespace oomph
{
  template<class ELEMENT>
  class SolidLubricationElement : public virtual FaceGeometry<ELEMENT>,
                                  public virtual SolidFaceElement
  {
  public:
    /// Function pointer to function that specifies the artificial repulsion
    typedef void (*ArtificialRepulsionFctPt)(const double& t,
                                             const double& h,
                                             double& f);

  private:
    /// Pointer to Film Cutoff
    double* Film_Cutoff_pt;

    // Pointer to conduction source term
    double* Conduction_source_pt;

    // Pointer to pressure scaling parameter
    double* Pressure_scaling_param_pt;

    // Pointer to surface tension
    double* Sigma_pt;

    // Pointer to artificial repulsion force
    ArtificialRepulsionFctPt Artificial_repulsion_fct_pt;

  protected:
    /// Index at which the vapour pressure is stored at the nodes
    Vector<unsigned> Pv_index;

    /// Default value of the physical constants
    static double Default_Physical_Constant_Value;

    /// Get the Vapour Pressure
    double interpolated_Pv(const Vector<double>& s);

    // Residual contributions from the element
    void fill_in_generic_residual_contribution_solid_lubrication(
      Vector<double>& residuals, DenseMatrix<double>& jacobian, unsigned flag);

    /// QElement helpful for residual contributions
    QElement<1, 3>* el_pt;

  public:
    /// Constructor
    /// The optional identifier can be used
    /// to distinguish the additional nodal value (Lagr mult) created by
    /// this element from those created by other FaceElements.
    SolidLubricationElement(FiniteElement* const& bulk_el_pt,
                            const int& face_index,
                            const unsigned& id = 0)
      : FaceGeometry<ELEMENT>(), FaceElement()
    {
      // Initialize paramater pointers
      Film_Cutoff_pt = &Default_Physical_Constant_Value;
      Conduction_source_pt = &Default_Physical_Constant_Value;
      Pressure_scaling_param_pt = &Default_Physical_Constant_Value;
      Sigma_pt = &Default_Physical_Constant_Value;
      Artificial_repulsion_fct_pt = 0;

      // Attach the geometrical information to the element. N.B. This function
      // also assigns nbulk_value from the required_nvalue of the bulk element
      bulk_el_pt->build_face_element(face_index, this);

      // Find the number of nodes in the face element
      unsigned n_node_face = this->nnode();

      // Vector for number of additional values at each node. One for vapour
      // pressure
      Vector<unsigned> additional_data_values(n_node_face, 1);

      // Now add storage for Lagrange multipliers and set the map containing
      // the position of the first entry of this face element's
      // additional values.
      this->add_additional_values(additional_data_values, id);

      // Setup the equation indices
      Vector<unsigned> pv_index(n_node_face);
      for (unsigned n = 0; n < n_node_face; n++)
      {
        pv_index[n] = dynamic_cast<BoundaryNodeBase*>(this->node_pt(n))
                        ->index_of_first_value_assigned_by_face_element(id);
      }
      set_pv_index(pv_index);

      // Create a Q element with 3 nodes (assuming for now there are three)
      el_pt = new QElement<1, 3>();

      // Set the nodal positions of the QElement (radial nodal position of the
      // surface element)
      for (unsigned l = 0; l < n_node_face; l++)
      {
        el_pt->node_pt(l) = new Node(1, 1, 1, true);
        el_pt->node_pt(l)->x(0) = nodal_position(l, 0);
      }
    }

    /// Destructor should not delete anything
    ~SolidLubricationElement()
    {
      // Delete allocated QElement and its nodes
      unsigned n_node = this->nnode();
      for (unsigned l = 0; l < n_node; l++)
      {
        delete el_pt->node_pt(l);
      }
      delete el_pt;
    }

    /// Compute the element residual vector
    inline void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      // Call the generic residuals function with flag set to 0
      // using a dummy matrix argument
      fill_in_generic_residual_contribution_solid_lubrication(
        residuals, GeneralisedElement::Dummy_matrix, 0);
    }

    /// Compute the element's residual vector and its Jacobian matrix
    inline void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                                 DenseMatrix<double>& jacobian)
    {
      // Call the generic routine with the flag set to 1
      fill_in_generic_residual_contribution_solid_lubrication(
        residuals, jacobian, 1);

      // Nodal position entries are too complicated. Do these via fd instead
      this->fill_in_jacobian_from_solid_position_by_fd(residuals, jacobian);
    }

    // Compute the element's surface power contribution
    void compute_surface_power_contribution(double& p_el);

    // Set the pv_index
    inline void set_pv_index(const Vector<unsigned>& pv_index)
    {
      this->Pv_index = pv_index;
    }

    /// Overload the output function in .cc file
    void output(std::ostream& outfile)
    {
      FiniteElement::output(outfile);
    }

    /// Overload the output function
    void output(std::ostream& outfile, const unsigned& n_plot);

    /// Overload the C-style output function
    void output(FILE* file_pt)
    {
      FiniteElement::output(file_pt);
    }

    /// C-style Output function
    void output(FILE* file_pt, const unsigned& n_plot)
    {
      FiniteElement::output(file_pt, n_plot);
    }

    /// Return the Film Cutoff
    double film_cutoff()
    {
      return *Film_Cutoff_pt;
    }

    /// Return the conduction source term
    double conduction_source()
    {
      return *Conduction_source_pt;
    }

    /// Return the pressure scaling parameter
    double pressure_scaling_param()
    {
      return *Pressure_scaling_param_pt;
    }

    /// Access function: Pointer to body force function
    ArtificialRepulsionFctPt& artificial_repulsion_fct_pt()
    {
      return Artificial_repulsion_fct_pt;
    }

    /// Access function: Pointer to body force function (const version)
    ArtificialRepulsionFctPt artificial_repulsion_fct_pt() const
    {
      return Artificial_repulsion_fct_pt;
    }

    /// Evaluate artificial repulsion
    inline void artificial_repulsion(const double& h, double& f) const
    {
      // If no function has been set, return zero
      if (Artificial_repulsion_fct_pt == 0)
      {
        f = 0.0;
      }
      else
      {
        // Get time from timestepper of first node
        double time = node_pt(0)->time_stepper_pt()->time_pt()->time();

        // Now evaluate the force
        (*Artificial_repulsion_fct_pt)(time, h, f);
      }
    }

    /// Return the surface tension
    double sigma()
    {
      return *Sigma_pt;
    }

    /// Access function for film cutoff
    double*& film_cutoff_pt()
    {
      return Film_Cutoff_pt;
    }

    /// Access function for conduction source
    double*& conduction_source_pt()
    {
      return Conduction_source_pt;
    }

    /// Access function for conduction source
    double*& pressure_scaling_param_pt()
    {
      return Pressure_scaling_param_pt;
    }

    /// Access function for surface tension
    double*& sigma_pt()
    {
      return Sigma_pt;
    }

    // fix the vapour pressure
    void fix_vapour_pressure(const unsigned& pv_dof, const double& pv_value)
    {
      this->node_pt(pv_dof)->pin(this->Pv_index[pv_dof]);
      this->node_pt(pv_dof)->set_value(this->Pv_index[pv_dof], pv_value);
    }

    // fix the vapour pressure
    void unpin_vapour_pressure(const unsigned& pv_dof)
    {
      this->node_pt(pv_dof)->unpin(this->Pv_index[pv_dof]);
    }

    // set the vapour pressure (e.g for initial condition)
    void set_vapour_pressure(const unsigned& pv_dof, const double& pv_value)
    {
      this->node_pt(pv_dof)->set_value(this->Pv_index[pv_dof], pv_value);
    }
  };

  // Define the default physical value to be zero
  template<class ELEMENT>
  double SolidLubricationElement<ELEMENT>::Default_Physical_Constant_Value =
    0.0;

  //=======================================================================
  template<class ELEMENT>
  void SolidLubricationElement<ELEMENT>::
    fill_in_generic_residual_contribution_solid_lubrication(
      Vector<double>& residuals, DenseMatrix<double>& jacobian, unsigned flag)
  {
    // Find out how many nodes there are
    const unsigned n_node = this->nnode();

    // Set the value of n_intpt
    unsigned n_intpt = integral_pt()->nweight();

    // n_intpt for the vapour
    unsigned n_intpt_vap = el_pt->integral_pt()->nweight();

    // Get the timestepper from first node
    TimeStepper* time_stepper_pt = this->node_pt(0)->time_stepper_pt();

    // Get the number of values required to represent history
    const unsigned n_time = time_stepper_pt->ntstorage();

    // Integers to hold the local equation number and local unknown
    int local_eqn = 0;
    int local_unknown = 0;

    // Set up memory for the shape functions
    Shape psi(n_node);
    DShape dpsids(n_node, 1);
    DShape dpsidS_div(n_node, 2);
    DShape dpsidS(n_node, 2);

    // Set up memory for vapour shape functions
    Shape psi_v(n_node);
    DShape dpsi_vdx(n_node, 1);

    // Get physical constants
    const double FilmCutoff = this->film_cutoff();
    const double SourceTerm = this->conduction_source();
    const double PressureScalingParam = this->pressure_scaling_param();
    const double Sigma = this->sigma();

    // Loop over integration points for the vapour
    for (unsigned ipt = 0; ipt < n_intpt_vap; ipt++)
    {
      // Get the integral weight
      double w = el_pt->integral_pt()->weight(ipt);

      // Call the shape functions and derivatives
      double J =
        std::fabs(el_pt->dshape_eulerian_at_knot(ipt, psi_v, dpsi_vdx));

      // Pre-multiply weights
      double W = w * J;

      // Containers for quantities
      Vector<double> interpolated_x(2, 0.0);
      double interpolated_pv = 0.0;
      double interpolated_dpvdx = 0.0;
      double interpolated_dhdx = 0.0;
      Vector<double> dx_dt(2, 0.0);
      double interpolated_dfdx = 0.0;

      // Loop over nodes
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop over directions
        for (unsigned i = 0; i < 2; i++)
        {
          // Positions
          interpolated_x[i] += nodal_position(l, i) * psi_v(l);

          // Time derivative of positions
          dx_dt[i] += dnodal_position_dt(l, i) * psi_v(l);
        }

        // Height derivative
        interpolated_dhdx += nodal_position(l, 1) * dpsi_vdx(l, 0);

        // Pressure
        interpolated_pv += nodal_value(l, Pv_index[l]) * psi_v(l);

        // Derivative of pressure
        interpolated_dpvdx += nodal_value(l, Pv_index[l]) * dpsi_vdx(l, 0);

        // Derivative of artificial repulsive term
        double f_tmp = 0.0;
        artificial_repulsion(nodal_position(l, 1), f_tmp);
        interpolated_dfdx += f_tmp * dpsi_vdx(l, 0);
      }

      // Loop over test functions
      for (unsigned l = 0; l < n_node; l++)
      {
        //-----------Lubrication eqn for vapour---------------------//

        // Get the local equation number
        local_eqn = this->nodal_local_eqn(l, Pv_index[l]);

        // If not a boundary condition
        if (local_eqn >= 0)
        {
          // Height derivative (accounting for moving frame) and source term
          residuals[local_eqn] += (dx_dt[1] - dx_dt[0] * interpolated_dhdx -
                                   SourceTerm / interpolated_x[1]) *
                                  psi_v(l) * interpolated_x[0] * W;

          // Flux term
          residuals[local_eqn] -= (-(pow(interpolated_x[1], 3.0) / 12.0) *
                                     (interpolated_dpvdx - interpolated_dfdx) +
                                   dx_dt[0] * interpolated_x[1] / 2.0) *
                                  dpsi_vdx(l, 0) * interpolated_x[0] * W;

          // If doing an analytic Jacobian
          if (flag)
          {
            // Loop over test functions again
            for (unsigned ll = 0; ll < n_node; ll++)
            {
              // Local unknown for vapour pressure
              local_unknown = this->nodal_local_eqn(ll, Pv_index[ll]);

              // If not a boundary condition
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) +=
                  dpsi_vdx(l, 0) * (pow(interpolated_x[1], 3.0) / 12.0) *
                  dpsi_vdx(ll, 0) * interpolated_x[0] * W;
              }
            }
          }
        }
        //----------------------------------------------------------//
      } // End of test function loop
    } // End of integration point loop for vapour

    // Loop over integration points
    for (unsigned ipt = 0; ipt < n_intpt; ipt++)
    {
      // Get the integral weight
      double w = integral_pt()->weight(ipt);

      // Only need to call the local derivatives
      dshape_local_at_knot(ipt, psi, dpsids);

      // Interpolated position and its derivative w.r.t. surface coordinate
      Vector<double> interpolated_x(2, 0.0);
      Vector<double> interpolated_dxds(2, 0.0);

      // First time derivative of position
      Vector<double> interpolated_dxdt(2, 0.0);

      // The vapour pressure and its derivative w.r.t. surface coordinate
      double interpolated_pv = 0.0;
      double interpolated_dpvds = 0.0;

      // Calculate displacements and derivatives
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop over directions
        for (unsigned i = 0; i < 2; i++)
        {
          // Calculate the Eulerian coords
          const double x_local = nodal_position(l, i);
          interpolated_x[i] += x_local * psi(l);

          // Derivative of position w.r.t boundary coord s
          interpolated_dxds[i] += x_local * dpsids(l, 0);

          // Loop over history values
          for (unsigned t = 0; t < n_time; t++)
          {
            // Add the contribution to the derivative
            interpolated_dxdt[i] +=
              time_stepper_pt->weight(1, t) * nodal_position(t, l, i) * psi(l);
          }
        }

        // Vapour pressure
        const double pv_value = nodal_value(l, Pv_index[l]);
        interpolated_pv += pv_value * psi(l);

        // Derivative of vapour pressure
        interpolated_dpvds += pv_value * dpsids(l, 0);
      }

      // Compute the surface derivatives of shape functions
      for (unsigned l = 0; l < n_node; l++)
      {
        // Standard components
        for (unsigned i = 0; i < 2; i++)
        {
          dpsidS(l, i) = dpsids(l, 0) * interpolated_dxds[i] /
                         (interpolated_dxds[0] * interpolated_dxds[0] +
                          interpolated_dxds[1] * interpolated_dxds[1]);
          dpsidS_div(l, i) = dpsidS(l, i);
        }

        // Accounting for axisymmetry
        dpsidS_div(l, 0) += psi(l) / interpolated_x[0];
      }

      // Now find the deformed local metric tensor (determinant) from the
      // tangent vectors
      double A_det = interpolated_x[0] * interpolated_x[0] *
                     (interpolated_dxds[0] * interpolated_dxds[0] +
                      interpolated_dxds[1] * interpolated_dxds[1]);

      // Premultiply the weights and the square-root of
      // the determinant of the metric tensor
      double W = w * sqrt(A_det);

      // Get the outer unit normal
      Vector<double> interpolated_normal(2);
      outer_unit_normal(ipt, interpolated_normal);

      // Are we on the base of the drop?
      bool film_flag = false;
      if (interpolated_normal[1] < -FilmCutoff)
      {
        film_flag = true;
      }

      // Loop over the test functions, nodes of the element
      for (unsigned l = 0; l < n_node; l++)
      {
        //-----------Stresses from vapour on solid------------------//
        // Loop over displacement components
        for (unsigned i = 0; i < 2; i++)
        {
          local_eqn = this->position_local_eqn(l, 0, i);

          // If not a boundary condition
          if (local_eqn >= 0)
          {
            if (film_flag)
            {
              residuals[local_eqn] += PressureScalingParam * interpolated_pv *
                                      interpolated_normal[i] * psi(l) * W;
              if (i == 0)
              {
                residuals[local_eqn] -=
                  PressureScalingParam *
                  (0.5 * interpolated_x[1] *
                     (interpolated_dpvds / interpolated_dxds[0]) +
                   interpolated_dxdt[0] / interpolated_x[1]) *
                  psi(l) * interpolated_normal[1] * W;
              }
              if (i == 1)
              {
                residuals[local_eqn] -=
                  PressureScalingParam *
                  (0.5 * interpolated_x[1] *
                     (interpolated_dpvds / interpolated_dxds[0]) +
                   interpolated_dxdt[0] / interpolated_x[1]) *
                  psi(l) * interpolated_normal[0] * W;
              }

              // If doing the Jacobian analytically
              if (flag)
              {
                // Loop over nodes again
                for (unsigned ll = 0; ll < n_node; ll++)
                {
                  // Local unknown for vapour pressure
                  local_unknown = this->nodal_local_eqn(ll, Pv_index[ll]);

                  // If not a boundary condition
                  if (local_unknown >= 0)
                  {
                    jacobian(local_eqn, local_unknown) +=
                      PressureScalingParam * psi(ll) * interpolated_normal[i] *
                      psi(l) * W;

                    if (i == 0)
                    {
                      jacobian(local_eqn, local_unknown) -=
                        PressureScalingParam *
                        (0.5 * interpolated_x[1] * dpsids(ll, 0) /
                         interpolated_dxds[0]) *
                        psi(l) * interpolated_normal[1] * W;
                    }
                    if (i == 1)
                    {
                      jacobian(local_eqn, local_unknown) -=
                        PressureScalingParam *
                        (0.5 * interpolated_x[1] * dpsids(ll, 0) /
                         interpolated_dxds[0]) *
                        psi(l) * interpolated_normal[0] * W;
                    }
                  }
                }
              }
            }

            // Surface tension contribution
            residuals[local_eqn] += Sigma * dpsidS_div(l, i) * W;
          }
        }
        //----------------------------------------------------------//
      } // End of test function loop
    } // End of integration point loop
  }

  //=======================================================
  /// Compute the elements contribution to power
  //=======================================================
  template<class ELEMENT>
  void SolidLubricationElement<ELEMENT>::compute_surface_power_contribution(
    double& p_el)
  {
    // Intitialize the contribution
    p_el = 0.0;

    // Find out how many nodes there are
    const unsigned n_node = this->nnode();

    // Set the value of n_intpt
    unsigned n_intpt = integral_pt()->nweight();

    // Get the timestepper from first node
    TimeStepper* time_stepper_pt = this->node_pt(0)->time_stepper_pt();

    // Get the number of values required to represent history
    const unsigned n_time = time_stepper_pt->ntstorage();

    // Set up memory for the shape functions
    Shape psi(n_node);
    DShape dpsids(n_node, 1);
    DShape dpsidS_div(n_node, 2);
    DShape dpsidS(n_node, 2);

    // Get physical constants
    const double FilmCutoff = this->film_cutoff();
    const double PressureScalingParam = this->pressure_scaling_param();

    // Loop over integration points
    for (unsigned ipt = 0; ipt < n_intpt; ipt++)
    {
      // Get the integral weight
      double w = integral_pt()->weight(ipt);

      // Only need to call the local derivatives
      dshape_local_at_knot(ipt, psi, dpsids);

      // Interpolated position and its derivative w.r.t. surface coordinate
      Vector<double> interpolated_x(2, 0.0);
      Vector<double> interpolated_dxds(2, 0.0);

      // First time derivative of position
      Vector<double> interpolated_dxdt(2, 0.0);

      // The vapour pressure and its derivative w.r.t. surface coordinate
      double interpolated_pv = 0.0;
      double interpolated_dpvds = 0.0;

      // Calculate displacements and derivatives
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop over directions
        for (unsigned i = 0; i < 2; i++)
        {
          // Calculate the Eulerian coords
          const double x_local = nodal_position(l, i);
          interpolated_x[i] += x_local * psi(l);

          // Derivative of position w.r.t boundary coord s
          interpolated_dxds[i] += x_local * dpsids(l, 0);

          // Loop over history values
          for (unsigned t = 0; t < n_time; t++)
          {
            // Add the contribution to the derivative
            interpolated_dxdt[i] +=
              time_stepper_pt->weight(1, t) * nodal_position(t, l, i) * psi(l);
          }
        }

        // Vapour pressure
        const double pv_value = nodal_value(l, Pv_index[l]);
        interpolated_pv += pv_value * psi(l);

        // Derivative of vapour pressure
        interpolated_dpvds += pv_value * dpsids(l, 0);
      }

      // Compute the surface derivatives of shape functions
      for (unsigned l = 0; l < n_node; l++)
      {
        // Standard components
        for (unsigned i = 0; i < 2; i++)
        {
          dpsidS(l, i) = dpsids(l, 0) * interpolated_dxds[i] /
                         (interpolated_dxds[0] * interpolated_dxds[0] +
                          interpolated_dxds[1] * interpolated_dxds[1]);
          dpsidS_div(l, i) = dpsidS(l, i);
        }

        // Accounting for axisymmetry
        dpsidS_div(l, 0) += psi(l) / interpolated_x[0];
      }

      // Now find the deformed local metric tensor (determinant) from the
      // tangent vectors
      double A_det = interpolated_x[0] * interpolated_x[0] *
                     (interpolated_dxds[0] * interpolated_dxds[0] +
                      interpolated_dxds[1] * interpolated_dxds[1]);

      // Premultiply the weights and the square-root of
      // the determinant of the metric tensor
      double W = w * sqrt(A_det);

      // Get the outer unit normal
      Vector<double> interpolated_normal(2);
      outer_unit_normal(ipt, interpolated_normal);

      // Are we on the base of the drop?
      bool film_flag = false;
      if (interpolated_normal[1] < -FilmCutoff)
      {
        film_flag = true;
      }

      if (film_flag)
      {
        // r-component
        p_el += PressureScalingParam *
                (-interpolated_pv * interpolated_normal[0] +
                 (0.5 * interpolated_x[1] *
                    (interpolated_dpvds / interpolated_dxds[0]) +
                  interpolated_dxdt[0] / interpolated_x[1]) *
                   interpolated_normal[1]) *
                interpolated_dxdt[0] * W;

        // z-component
        p_el += PressureScalingParam *
                (-interpolated_pv * interpolated_normal[1] +
                 (0.5 * interpolated_x[1] *
                    (interpolated_dpvds / interpolated_dxds[0]) +
                  interpolated_dxdt[0] / interpolated_x[1]) *
                   interpolated_normal[0]) *
                interpolated_dxdt[1] * W;
      }
    } // End of integration point loop
  }

  //=======================================================
  /// Overload the output function
  //=======================================================
  template<class ELEMENT>
  void SolidLubricationElement<ELEMENT>::output(std::ostream& outfile,
                                                const unsigned& n_plot)
  {
    outfile.precision(16);

    // Set output Vector
    Vector<double> s(1);

    // Loop over plot points
    unsigned num_plot_points = this->nplot_points(n_plot);
    for (unsigned iplot = 0; iplot < num_plot_points; iplot++)
    {
      // Get local coordinates of plot point
      this->get_s_plot(iplot, n_plot, s);

      // Output the x,y,u_r,u_z
      for (unsigned i = 0; i < 2; i++)
      {
        outfile << this->interpolated_x(s, i) << " ";
      }

      // Also output the Lagrangian coord (can be used to sort the boundary)
      for (unsigned i = 0; i < 2; i++)
      {
        outfile << this->interpolated_xi(s, i) << " ";
      }

      // Output the vapour pressure
      outfile << interpolated_Pv(s) << " ";

      outfile << std::endl;
    }
  }

  //=====================================================================
  /// Get the Vapour pressure
  //=====================================================================
  template<class ELEMENT>
  double SolidLubricationElement<ELEMENT>::interpolated_Pv(
    const Vector<double>& s)
  {
    // Find number of nodes
    unsigned n_node = this->nnode();

    // Local shape function
    Shape psi(n_node);

    // Find values of shape function
    this->shape(s, psi);

    // Initialise value of Pv
    double Pv = 0.0;

    // Loop over the local nodes and sum
    for (unsigned l = 0; l < n_node; l++)
    {
      Pv += this->nodal_value(l, this->Pv_index[l]) * psi(l);
    }

    return (Pv);
  }
} // namespace oomph
#endif
