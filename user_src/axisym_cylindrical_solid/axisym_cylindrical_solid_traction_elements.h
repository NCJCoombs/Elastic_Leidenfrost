// Header file for elements that are used to apply surface loads to
// the equations of elasticity

#ifndef OOMPH_AXISYMM_SOLID_TRACTION_ELEMENTS_HEADER
#define OOMPH_AXISYMM_SOLID_TRACTION_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// OOMPH-LIB headers
#include "../generic/Qelements.h"

namespace oomph
{
  //======================================================================
  /// A class for elements that allow the imposition of an applied traction
  /// in the principle of virtual displacements.
  /// The geometrical information can be read from the FaceGeometry<ELEMENT>
  /// class and and thus, we can be generic enough without the need to have
  /// a separate equations class.
  //======================================================================
  template<class ELEMENT>
  class AxisymmetricCylindricalSolidTractionElement
    : public virtual FaceGeometry<ELEMENT>,
      public virtual SolidFaceElement
  {
  private:
    /// Pointer to an imposed traction function
    void (*Traction_fct_pt)(const double& time,
                            const Vector<double>& x,
                            const Vector<double>& n,
                            Vector<double>& result);

  protected:
    /// Return the surface traction force
    void get_traction(const double& time,
                      const Vector<double>& x,
                      const Vector<double>& n,
                      Vector<double>& result) const
    {
      // If the function pointer is zero return zero
      if (Traction_fct_pt == 0)
      {
        // Loop over dimensions and set body forces to zero
        // It's axisymmetric, so we only have "two" dimensions
        for (unsigned i = 0; i < 2; i++)
        {
          result[i] = 0.0;
        }
      }
      // Otherwise call the function
      else
      {
        (*Traction_fct_pt)(time, x, n, result);
      }
    }

  public:
    /// Constructor, which takes a "bulk" element and
    /// the value of the index and its limit
    AxisymmetricCylindricalSolidTractionElement(
      FiniteElement* const& element_pt, const int& face_index)
      : FaceGeometry<ELEMENT>(), FaceElement()
    {
      // Attach the geometrical information to the element. N.B. This function
      // also assigns nbulk_value from the required_nvalue of the bulk element
      element_pt->build_face_element(face_index, this);

      // Set the body force function pointer to zero
      Traction_fct_pt = 0;
    }

    /// Return the imposed traction pointer
    void (*&traction_fct_pt())(const double&,
                               const Vector<double>&,
                               const Vector<double>&,
                               Vector<double>&)
    {
      return Traction_fct_pt;
    }

    /// Return the residuals
    void fill_in_contribution_to_residuals(Vector<double>& residuals);

    /// Return the jacobian
    void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                          DenseMatrix<double>& jacobian)
    {
      fill_in_contribution_to_residuals(residuals);
      // Call the generic FD jacobian calculation
      FaceGeometry<ELEMENT>::fill_in_jacobian_from_solid_position_by_fd(
        jacobian);
    }

    /// Overload the output function
    void output(std::ostream& outfile)
    {
      FiniteElement::output(outfile);
    }

    /// Output function: x,y,[z],u,v,[w],p in tecplot format
    void output(std::ostream& outfile, const unsigned& n_plot)
    {
      FiniteElement::output(outfile, n_plot);
    }

    /// Overload the output function
    void output(FILE* file_pt)
    {
      FiniteElement::output(file_pt);
    }

    /// Output function: x,y,[z],u,v,[w],p in tecplot format
    void output(FILE* file_pt, const unsigned& n_plot)
    {
      FiniteElement::output(file_pt, n_plot);
    }
  };


  /// //////////////////////////////////////////////////////////////////////
  /// //////////////////////////////////////////////////////////////////////
  /// //////////////////////////////////////////////////////////////////////


  //=======================================================================
  /// Return the residuals for the AxisymmetricCylindricalSolidTractionElements
  //=======================================================================
  template<class ELEMENT>
  void AxisymmetricCylindricalSolidTractionElement<
    ELEMENT>::fill_in_contribution_to_residuals(Vector<double>& residuals)
  {
    // Find out how many nodes there are
    unsigned n_node = nnode();

    // Integer to hold the local equation number
    int local_eqn = 0;

    // Set up memory for the shape functions
    // The surface is 1D, so we only have one local derivative
    Shape psi(n_node);
    DShape dpsids(n_node, 1);

    // Set the value of n_intpt
    unsigned n_intpt = integral_pt()->nweight();

    // Get the timestepper from the first node
    TimeStepper* time_step_pt = this->node_pt(0)->time_stepper_pt();

    // Loop over the integration points
    for (unsigned ipt = 0; ipt < n_intpt; ipt++)
    {
      // Get the integral weight
      double w = integral_pt()->weight(ipt);

      // Only need to call the local derivatives
      dshape_local_at_knot(ipt, psi, dpsids);

      // Calculate the global position and lagrangian coordinate
      Vector<double> interpolated_x(2, 0.0), interpolated_xi(2, 0.0);
      // Calculate the global and lagrangian derivtives wrt the local
      // coordinates
      Vector<double> interpolated_dxds(2, 0.0), interpolated_dxids(2, 0.0);

      // Calculate displacements and derivatives
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop over the number of lagrangian coordinates (2)
        for (unsigned i = 0; i < 2; i++)
        {
          // Calculate the global position
          interpolated_x[i] += nodal_position(l, i) * psi(l);
          interpolated_xi[i] += this->lagrangian_position(l, i) * psi(l);
          // Calculate the derivatives of the global and lagrangian
          // coordinates
          interpolated_dxds[i] += nodal_position(l, i) * dpsids(l, 0);
          interpolated_dxids[i] +=
            this->lagrangian_position(l, i) * dpsids(l, 0);
        }
      }

      // Now find the deformed local metric tensor (determinant) from the
      // tangent vectors
      double A_det = interpolated_x[0] * interpolated_x[0] *
                     (interpolated_dxds[0] * interpolated_dxds[0] +
                      interpolated_dxds[1] * interpolated_dxds[1]);

      // Premultiply the weights and the square-root of the determinant of
      // the metric tensor
      double W = w * sqrt(A_det);

      // Also find the normal
      Vector<double> interpolated_normal(2);
      outer_unit_normal(ipt, interpolated_normal);

      // Now calculate the load
      Vector<double> traction(2);

      // Normal is outwards
      get_traction(
        time_step_pt->time(), interpolated_x, interpolated_normal, traction);

      //=====LOAD TERMS  FROM PRINCIPLE OF VIRTUAL DISPLACEMENTS========

      // Loop over the test functions, nodes of the element
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop over the displacement components
        for (unsigned i = 0; i < 2; i++)
        {
          local_eqn = this->position_local_eqn(l, 0, i);
          /*IF it's not a boundary condition*/
          if (local_eqn >= 0)
          {
            // Add the loading terms to the residuals
            residuals[local_eqn] -= traction[i] * psi(l) * W;
          }
        }
      } // End of loop over shape functions
    } // End of loop over integration points
  }
} // namespace oomph

#endif
